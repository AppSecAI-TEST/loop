package loop;

import loop.ast.*;

import java.util.ArrayList;
import java.util.List;

/**
 * Takes an AST generated by the parser and strips it of unnecessary elements. Also optimizes the
 * AST to be in its most compact form.
 */
public class Reducer {
  private Node ast;

  public Reducer(Node ast) {
    this.ast = ast;
  }

  public Node reduce() {
    // Unwrap top level.
    if (shouldUnwrap(ast)) {
      ast = onlyChildOf(ast);
    }

    return reduce(ast);
  }

  private Node reduce(Node bloated) {
    List<Node> reduced = new ArrayList<Node>();
    for (Node node : bloated.children()) {
      node = reduce(node);

      // Unwrap any redundant wrappers.
      if (shouldUnwrap(node)) {
        reduced.add(onlyChildOf(node));
        continue;
      }

      reduced.add(node);
    }

    // Reduce non-children sub-nodes (many of these in various special cases).
    if (bloated instanceof IndexIntoList) {
      IndexIntoList indexIntoList = (IndexIntoList) bloated;

      // See if the nodes themselves merit reduction.
      if (null != indexIntoList.from()) {
        reduce(indexIntoList.from());
        if (shouldUnwrap(indexIntoList.from())) {
          indexIntoList.from(onlyChildOf(indexIntoList.from()));
        }
      }
      if (null != indexIntoList.to()) {
        reduce(indexIntoList.to());
        if (shouldUnwrap(indexIntoList.to())) {
          indexIntoList.to(onlyChildOf(indexIntoList.to()));
        }
      }
    } else if (bloated instanceof Comprehension) {
      Comprehension comprehension = (Comprehension) bloated;

      reduce(comprehension.inList());
      if (shouldUnwrap(comprehension.inList())) {
        comprehension.inList(onlyChildOf(comprehension.inList()));
      }

      // the filter clause is optional.
      if (null != comprehension.filter()) {
        reduce(comprehension.filter());
        if (shouldUnwrap(comprehension.filter())) {
          comprehension.filter(onlyChildOf(comprehension.filter()));
        }
      }
    } else if (bloated instanceof Call) {
      Call call = (Call) bloated;

      if (call.args() != null) {
        reduce(call.args());
      }
    } else if (bloated instanceof PatternRule) {
      PatternRule rule = (PatternRule) bloated;

      if (null != rule.rhs)
        reduce(rule.rhs);
    }

    bloated.children().clear();
    bloated.children().addAll(reduced);

    // Run through the entire list again and compress list comprehension nodes.
    reduceComprehension(reduced);

    return bloated;
  }

  private void reduceComprehension(List<Node> reduced) {
    for (Node node : reduced) {
      List<Node> children = node.children();
      if (!children.isEmpty()) {
        Node last = children.get(children.size() - 1);
        if (last instanceof Comprehension) {
          // Assign all preceding siblings as the "project expression"
          // E.g. (x) (+ 2) (for x in ls) becomes ((x + 2) for x in ls)
          List<Node> nodes = new ArrayList<Node>(children.subList(0, children.size() - 1));
          ((Comprehension) last).projection(nodes);

          // Delete the compressed nodes from the original parent.
          children.removeAll(nodes);
        }
      }
    }
  }

  private Node onlyChildOf(Node node) {
    return node.children().get(0);
  }

  private boolean shouldUnwrap(Node node) {
    return (node instanceof CallChain || node instanceof Computation)
        && node.children().size() == 1;
  }
}
